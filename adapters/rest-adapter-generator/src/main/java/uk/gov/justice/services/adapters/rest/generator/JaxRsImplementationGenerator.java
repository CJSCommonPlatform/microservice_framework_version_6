package uk.gov.justice.services.adapters.rest.generator;

import static com.squareup.javapoet.MethodSpec.methodBuilder;
import static com.squareup.javapoet.TypeSpec.classBuilder;
import static java.lang.String.format;
import static javax.lang.model.element.Modifier.FINAL;
import static javax.lang.model.element.Modifier.PRIVATE;
import static javax.lang.model.element.Modifier.PUBLIC;
import static javax.lang.model.element.Modifier.STATIC;
import static org.raml.model.ActionType.GET;
import static org.raml.model.ActionType.POST;
import static uk.gov.justice.raml.common.generator.Names.DEFAULT_ANNOTATION_PARAMETER;
import static uk.gov.justice.raml.common.generator.Names.GENERIC_PAYLOAD_ARGUMENT_NAME;
import static uk.gov.justice.raml.common.generator.Names.RESOURCE_PACKAGE_NAME;
import static uk.gov.justice.raml.common.generator.Names.buildResourceMethodName;
import static uk.gov.justice.raml.common.generator.Names.buildResourceMethodNameWithNoMimeType;
import static uk.gov.justice.raml.common.generator.Names.packageNameOf;
import static uk.gov.justice.raml.common.generator.Names.resourceImplementationNameOf;
import static uk.gov.justice.raml.common.generator.Names.resourceInterfaceNameOf;
import static uk.gov.justice.services.adapters.rest.generator.Generators.byMimeTypeOrder;
import static uk.gov.justice.services.adapters.rest.generator.Generators.componentFromBaseUriIn;

import uk.gov.justice.raml.core.GeneratorConfig;
import uk.gov.justice.services.adapter.rest.BasicActionMapper;
import uk.gov.justice.services.adapter.rest.parameter.ParameterType;
import uk.gov.justice.services.adapter.rest.parameter.ValidParameterCollectionBuilder;
import uk.gov.justice.services.adapter.rest.processor.RestProcessor;
import uk.gov.justice.services.core.annotation.Adapter;
import uk.gov.justice.services.core.annotation.Component;
import uk.gov.justice.services.core.dispatcher.AsynchronousDispatcher;
import uk.gov.justice.services.core.dispatcher.SynchronousDispatcher;
import uk.gov.justice.services.messaging.logging.HttpMessageLoggerHelper;
import uk.gov.justice.services.messaging.logging.LoggerUtils;

import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.Supplier;
import java.util.stream.Collectors;

import javax.inject.Inject;
import javax.inject.Named;
import javax.json.JsonObject;
import javax.ws.rs.core.Context;
import javax.ws.rs.core.HttpHeaders;
import javax.ws.rs.core.Response;

import com.squareup.javapoet.AnnotationSpec;
import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.CodeBlock;
import com.squareup.javapoet.FieldSpec;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.ParameterSpec;
import com.squareup.javapoet.TypeSpec;
import org.raml.model.Action;
import org.raml.model.ActionType;
import org.raml.model.Raml;
import org.raml.model.Resource;
import org.raml.model.parameter.QueryParameter;
import org.raml.model.parameter.UriParameter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Internal code generation class for generating the JAX-RS implementation class that implements the
 * Interface generated by the {@link JaxRsInterfaceGenerator}.
 */
class JaxRsImplementationGenerator {

    private static final String VARIABLE_PARAMS_COLLECTION_BUILDER = "validParameterCollectionBuilder";
    private static final String PARAMS_PUT_REQUIRED_STATEMENT_FORMAT = "$L.putRequired($S, $N, $T.$L)";
    private static final String PARAMS_PUT_OPTIONAL_STATEMENT_FORMAT = "$L.putOptional($S, $N, $T.$L)";
    private static final String SYNCHRONOUS_METHOD_STATEMENT = "return restProcessor.processSynchronously(syncDispatcher::dispatch, $L.actionOf($S, \"GET\", headers), headers, $L.parameters())";
    private static final String ASYNCHRONOUS_METHOD_STATEMENT = "return restProcessor.processAsynchronously(asyncDispatcher::dispatch, $L.actionOf($S, \"POST\", headers), entity, headers, $L.parameters())";
    private static final String ACTION_MAPPER_VARIABLE = "actionMapper";

    private final GeneratorConfig configuration;

    /**
     * Constructor.
     *
     * @param configuration the generator configuration
     */
    JaxRsImplementationGenerator(final GeneratorConfig configuration) {
        this.configuration = configuration;
    }

    /**
     * Generate an implementation class for each resource in raml.
     *
     * @param raml to generate as implementation classes
     * @return a list of {@link TypeSpec} that represent the implementation classes
     */
    List<TypeSpec> generateFor(final Raml raml) {
        final Component component = componentFromBaseUriIn(raml);
        final Collection<Resource> resources = raml.getResources().values();
        return resources.stream()
                .map(resource -> generateFor(resource, component))
                .collect(Collectors.toList());
    }

    /**
     * Create an implementation class for the specified {@link Resource}
     *
     * @param resource the resource to generate as an implementation class
     * @return a {@link TypeSpec} that represents the implementation class
     */
    TypeSpec generateFor(final Resource resource, final Component component) {
        final TypeSpec.Builder classSpecBuilder = classSpecFor(resource, component);

        resource.getActions().values().forEach(action -> {
            classSpecBuilder.addField(dispatcherFieldFor(action));
            classSpecBuilder.addMethods(forEach(action));
        });

        return classSpecBuilder.build();
    }

    /**
     * Creates a {@link TypeSpec.Builder} from an initial template of an implementation class
     *
     * @param resource  the resource to generate as an implementation class
     * @param component specifies the type of framework {@link Component} that is being implemented
     * @return a {@link TypeSpec.Builder} that represents the implementation class
     */
    private TypeSpec.Builder classSpecFor(final Resource resource, final Component component) {
        final String className = resourceImplementationNameOf(resource);
        return classBuilder(className)
                .addSuperinterface(interfaceClassNameFor(resource))
                .addModifiers(PUBLIC)
                .addAnnotation(AnnotationSpec.builder(Adapter.class)
                        .addMember(DEFAULT_ANNOTATION_PARAMETER, "$T.$L", Component.class, component)
                        .build())
                .addField(loggerConstantField(className))
                .addField(FieldSpec.builder(RestProcessor.class, "restProcessor")
                        .addAnnotation(Inject.class)
                        .build())
                .addField(FieldSpec.builder(BasicActionMapper.class, ACTION_MAPPER_VARIABLE)
                        .addAnnotation(Inject.class)
                        .addAnnotation(AnnotationSpec.builder(Named.class)
                                .addMember(DEFAULT_ANNOTATION_PARAMETER, "$S", className + "ActionMapper").build())
                        .build())
                .addField(FieldSpec.builder(HttpHeaders.class, "headers")
                        .addAnnotation(Context.class)
                        .build());
    }



    /**
     * Process the body or bodies for each httpAction.
     *
     * @param action the httpAction to process
     * @return the list of {@link MethodSpec} that represents each method for the httpAction
     */
    private List<MethodSpec> forEach(final Action action) {
        if (!action.hasBody()) {
            return Collections.singletonList(processNoActionBody(action));
        } else {
            return processOneOrMoreActionBodies(action);
        }
    }

    /**
     * Process an httpAction with no body.
     *
     * @param action the httpAction to process
     * @return the {@link MethodSpec} that represents the method for the httpAction
     */
    private MethodSpec processNoActionBody(final Action action) {
        final String resourceMethodName = buildResourceMethodNameWithNoMimeType(action);
        return generateResourceMethod(action, resourceMethodName).build();
    }

    /**
     * Process an httpAction with one or more bodies.
     *
     * @param action the httpAction to process
     * @return the list of {@link MethodSpec} that represents each method for the httpAction
     */
    private List<MethodSpec> processOneOrMoreActionBodies(final Action action) {
        return action.getBody().values().stream()
                .sorted(byMimeTypeOrder())
                .map(bodyMimeType -> {
                    final String resourceMethodName = buildResourceMethodName(action, bodyMimeType);
                    final MethodSpec.Builder methodBuilder = generateResourceMethod(action, resourceMethodName);
                    return addToMethodWithMimeType(methodBuilder).build();
                }).collect(Collectors.toList());
    }

    /**
     * Generate the interface class name for implementation class
     *
     * @param resource generate for resource
     * @return the {@link ClassName} of the interface
     */
    private ClassName interfaceClassNameFor(final Resource resource) {
        return ClassName.get(packageNameOf(configuration, RESOURCE_PACKAGE_NAME), resourceInterfaceNameOf(resource));
    }

    /**
     * Generate the Logger constant field.
     *
     * @return the {@link FieldSpec} that represents the generated field
     */
    private FieldSpec loggerConstantField(final String className) {
        final ClassName classLoggerFactory = ClassName.get(LoggerFactory.class);
        return FieldSpec.builder(Logger.class, "LOGGER")
                .addModifiers(PRIVATE, STATIC, FINAL)
                .initializer(
                        CodeBlock.builder()
                                .add(format("$L.getLogger(%s.class)", className), classLoggerFactory).build()
                )
                .build();
    }

    /**
     * Uses the type of {@link Action} to provide a {@link SynchronousDispatcher} or an {@link
     * AsynchronousDispatcher} and provides the correct field definition as a {@link FieldSpec}.
     *
     * @param action the httpAction to forEach
     * @return a {@link FieldSpec} representing the field definition.
     * @throws IllegalStateException if httpAction type is not GET or POST
     */
    private FieldSpec dispatcherFieldFor(final Action action) {
        final ActionType actionType = action.getType();

        if (actionType == GET) {
            return synchronousDispatcherField();
        } else if (actionType == POST) {
            return asynchronousDispatcherField();
        } else {
            throw new IllegalStateException(format("Unsupported httpAction type %s", actionType));
        }
    }

    /**
     * Generate the SynchronousDispatcher injected field.
     *
     * @return the {@link FieldSpec} that represents the generated field
     */
    private FieldSpec synchronousDispatcherField() {
        return FieldSpec.builder(SynchronousDispatcher.class, "syncDispatcher")
                .addAnnotation(Inject.class)
                .build();
    }

    /**
     * Generate the AsynchronousDispatcher injected field.
     *
     * @return the {@link FieldSpec} that represents the generated field
     */
    private FieldSpec asynchronousDispatcherField() {
        return FieldSpec.builder(AsynchronousDispatcher.class, "asyncDispatcher")
                .addAnnotation(Inject.class)
                .build();
    }

    /**
     * Add MimeType specific parameter to method.
     *
     * @param methodBuilder add parameter to this method builder
     * @return the method builder
     */
    private MethodSpec.Builder addToMethodWithMimeType(final MethodSpec.Builder methodBuilder) {
        return methodBuilder.addParameter(ParameterSpec
                .builder(JsonObject.class, GENERIC_PAYLOAD_ARGUMENT_NAME)
                .build());
    }

    /**
     * Generate a method for each {@link Action}.
     *
     * @param action             the httpAction to generate as a method
     * @param resourceMethodName the resource method name to generate
     * @return a {@link MethodSpec} that represents the generated method
     */
    private MethodSpec.Builder generateResourceMethod(final Action action,
                                                      final String resourceMethodName) {
        final ActionType actionType = action.getType();
        final Map<String, QueryParameter> queryParams = action.getQueryParameters();
        final Map<String, UriParameter> pathParams = action.getResource().getUriParameters();
        final CodeBlock methodBody;

        if (actionType == GET) {
            methodBody = methodBody(pathParams, () -> methodBodyForGet(queryParams, resourceMethodName));
        } else if (actionType == POST) {
            methodBody = methodBody(pathParams, () -> methodBodyForPost(resourceMethodName));
        } else {
            throw new IllegalStateException(format("Unsupported httpAction type %s", actionType));
        }

        return methodBuilder(resourceMethodName)
                .addModifiers(PUBLIC)
                .addAnnotation(Override.class)
                .addParameters(methodPathParams(pathParams))
                .addParameters(methodQueryParams(queryParams))
                .addCode(methodBody)
                .returns(Response.class);
    }

    /**
     * Produce code specific to the GET httpAction type.
     *
     * @param queryParams        the query parameters to add to a map
     * @param resourceMethodName name of the resource method
     * @return the {@link CodeBlock} representing the GET specific code
     */
    private CodeBlock methodBodyForGet(final Map<String, QueryParameter> queryParams, final String resourceMethodName) {
        return CodeBlock.builder()
                .add(putAllQueryParamsInCollectionBuilder(queryParams))
                .addStatement(SYNCHRONOUS_METHOD_STATEMENT,
                        ACTION_MAPPER_VARIABLE, resourceMethodName, VARIABLE_PARAMS_COLLECTION_BUILDER)
                .build();
    }

    /**
     * Produce code specific to the POST httpAction type.
     *
     * @param resourceMethodName name of the resource method
     * @return the {@link CodeBlock} representing the POST specific code
     */
    private CodeBlock methodBodyForPost(final String resourceMethodName) {
        return CodeBlock.builder()
                .addStatement(ASYNCHRONOUS_METHOD_STATEMENT,
                        ACTION_MAPPER_VARIABLE, resourceMethodName, VARIABLE_PARAMS_COLLECTION_BUILDER)
                .build();
    }

    /**
     * General code that is for both GET and POST httpAction type methods.
     *
     * @return the {@link CodeBlock} representing the general code
     */
    private CodeBlock methodBody(final Map<String, UriParameter> pathParams, final Supplier<CodeBlock> supplier) {
        final ClassName classMapBuilderType = ClassName.get(ValidParameterCollectionBuilder.class);
        final ClassName classLoggerUtils = ClassName.get(LoggerUtils.class);
        final ClassName classHttpMessageLoggerHelper = ClassName.get(HttpMessageLoggerHelper.class);


        return CodeBlock.builder()
                .addStatement("$T $L = new $T()", classMapBuilderType, VARIABLE_PARAMS_COLLECTION_BUILDER, classMapBuilderType)
                .addStatement("$T.trace(LOGGER, () -> String.format(\"Received REST request with headers: %s\", $T.toHttpHeaderTrace(headers)))",
                        classLoggerUtils, classHttpMessageLoggerHelper)
                .add(putAllPathParamsInCollectionBuilder(pathParams.keySet()))
                .add(supplier.get())
                .build();
    }

    /**
     * Generate code to add all path parameters to the params map.
     *
     * @param paramNames the params to add to the map
     * @return the {@link CodeBlock} that represents the generated code
     */
    private CodeBlock putAllPathParamsInCollectionBuilder(final Set<String> paramNames) {
        final CodeBlock.Builder builder = CodeBlock.builder();

        paramNames.stream().forEach(name ->
                builder.addStatement(PARAMS_PUT_REQUIRED_STATEMENT_FORMAT, VARIABLE_PARAMS_COLLECTION_BUILDER, name, name, ParameterType.class, "STRING")
        );

        return builder.build();
    }

    /**
     * Generate code to add all query parameters to the params map.
     *
     * @param parameters the params to add to the map
     * @return the {@link CodeBlock} that represents the generated code
     */
    private CodeBlock putAllQueryParamsInCollectionBuilder(final Map<String, QueryParameter> parameters) {
        final CodeBlock.Builder builder = CodeBlock.builder();

        parameters.entrySet().stream().forEach(paramEntry -> {
            final String name = paramEntry.getKey();
            final ParameterType parameterType = ParameterType.valueOf(paramEntry.getValue().getType());
            if (paramEntry.getValue().isRequired()) {
                        builder.addStatement(PARAMS_PUT_REQUIRED_STATEMENT_FORMAT, VARIABLE_PARAMS_COLLECTION_BUILDER, name, name, ParameterType.class, parameterType.name());
                    } else {
                        builder.addStatement(PARAMS_PUT_OPTIONAL_STATEMENT_FORMAT, VARIABLE_PARAMS_COLLECTION_BUILDER, name, name, ParameterType.class, parameterType.name());
                    }
                }
        );

        return builder.build();
    }

    /**
     * Generate method parameters for all the path params.
     *
     * @param pathParams the path params to generate
     * @return list of {@link ParameterSpec} that represent the method parameters
     */
    private List<ParameterSpec> methodPathParams(final Map<String, UriParameter> pathParams) {
        return pathParams.keySet().stream().map(name ->
                ParameterSpec
                        .builder(String.class, name)
                        .build())
                .collect(Collectors.toList());
    }

    /**
     * Generate method parameters for all the query params.
     *
     * @param queryParams the query params to generate
     * @return list of {@link ParameterSpec} that represent the method parameters
     */
    private List<ParameterSpec> methodQueryParams(final Map<String, QueryParameter> queryParams) {
        return queryParams.keySet().stream().map(name ->
                ParameterSpec.builder(String.class, name)
                        .build()
        ).collect(Collectors.toList());
    }
}
